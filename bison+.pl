#!/usr/bin/perl
#
# Perl script to "classify" a yacc generated parser (turn a yacc generated
# y.tab.c file into a C++ class definition).
#
# NOTE: This will probably only work on about 1/2 of the versions of yacc
# out there and will definitely NOT work on bison generated files.
#
# This reads y.tab.c and writes a .c and .h file. The .h file contains a
# custom class definition.  Each instance of the class can operate as a
# separate parser. A yyparse member function is defined, it is up to you to
# define the yylex and yyerror member functions.

# The base name of the .c and .h files is the same as the class name.

# Process options...
#
require "getopts.pl";

do Getopts('r:vdltH');

if (defined($opt_H)) {
print "yacc+ - run yacc and wrap the parser in a C++ class definition

usage: yacc+ [-H] [-d] [-l] [-r size] [-t] [-v] infile [class]

-H      Print this listing and exit.
-d      Ignored, but accepted for compatibility with yacc.
-l      Do not generate #line directives.
-r size Realloc stack when out of space, use 'size' as initial stack size.
-t      Turn on debugging by default.
-v      Generate verbose grammar analysis in file y.output.

This script runs yacc, and if it is successful, transforms the generated
y.tab.c file into a C++ class with a separate .h and .c file. The names of
the .c and .h files come from the basename of the input grammar file.  The
class name is also taken from the base name of the input file or from the
class name specified as the second argument.

Notes:
   * This transformation only works on grammar files which contain a \%union
     definition.
   * You will need to define your own <classname>::yylex and
     <classname>::yyerror functions to complete the class definition.
   * Include a line in the yacc input header that looks like \"/*classdef\"
     to have everything following it (up to the line \"*/\") copied
     into the generated class definition.
   * Include a line in the yacc input header that looks like \"/*headerdef\"
     to have everything following it (up to the line \"*/\") copied
     into the generated header file prior to the class definition.
";
   exit 0;

}

# Get grammar file and class name...
#
if ($#ARGV >= 0) {
   $yaccin=$ARGV[0];
   if ($#ARGV >= 1) {
      $class=$ARGV[1];
      if ($#ARGV >= 2) {
         die "Extra command line arguments ignored.\n";
      }
   } else {
      if ($yaccin=~/^([a-zA-Z_][a-zA-Z_0-9]*)/) {
         $class=$1;
      } else {
         die "Cannot determine name for class.\n";
      }
   }
} else {

   die "Missing input file name on command line.\n";

}

if (defined($opt_t)) {
   $yydebug=1;

} else {
   $yydebug=0;
}

# Get base name of input file (used to construct output file names)
#
if ($yaccin=~/^.*\/([^\/]+)$/) {
   $yaccbase = $1;
} else {
   $yaccbase = $yaccin;
}

if ($yaccbase=~/(.+)\.[^.]*$/) {
   $yaccbase=$1;

}

# Run yacc
#
print "Running yacc..\n";
unlink("y.tab.c");
push(@runyacc, "bison");
push(@runyacc, "-y");
push(@runyacc, "-v") if (defined($opt_v));
push(@runyacc, "-l") if (defined($opt_l));
push(@runyacc, $yaccin);
$yaccstat = system(@runyacc);
if ($yaccstat != 0) {
   die "@runyacc failed.\n";

}

# Create C++ files
#
print "Creating C++ files at $yaccbase..\n";
$cfile=$yaccbase . ".cpp";
$hfile=$yaccbase . ".h";
open(YTABC, "y.tab.c") || die "No y.tab.c file in current directory.\n";
open(HFILE, ">$hfile") || die "Cannot write $hfile\n";
open(CFILE, ">$cfile") || die "Cannot write $cfile\n";

# Write standard header to .h file. (This knows A LOT about what sort of
# gibberish is generated by yacc).
#
print HFILE
"#ifndef ${class}_h
#define ${class}_h
";
if (defined($opt_r)) {
   print HFILE "\n#include <stdlib.h>\n";
}

print HFILE
"
#ifndef yyclearin

#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
typedef int yytabelem;
typedef struct { char *t_name; int t_val; } yytoktype;

#endif

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif

#ifndef YYDEBUG
#       define YYDEBUG  $yydebug
#endif

";

$printedclass = 0;

# Copy header of y.tab.c file to output .c file until reaching the
# point where the YYSTYPE union is defined.
#
while (<YTABC>) {
  print "HFILE 3 line: $_";
   if (/^\#define[ \t]*YYSTYPE[ \t]*int$/) {
      die "Input grammar file does not contain a \%union definition!\n";
   } elsif (/^\/\*headerdef$/) {
     print "  Adding header..\n";

      # The line: "/*headerdef" just appeared. Accumulate everything
      # until a closing "*/" on a line by itself and put it in the
      # class header file.

      if ($printedclass) {
         die "/*headerdef must come first in source!\n";
      }
      while (<YTABC>) {
         if (/^\*\/$/) {
            $_ = "";
            last;
         }
         print HFILE $_;
      }
   } elsif (/^\/\*classdef$/) {

     print "  Adding class..\n";
      # The line: "/*classdef" just appeared. Accumulate everything
      # until a closing "*/" on a line by itself and put it in the
      # class definition.

      if (! $printedclass) {
         print HFILE "class $class {\n";
         $printedclass = 1;
      }
      while (<YTABC>) {
         if (/^\*\/$/) {
            $_ = "";
            last;
         }
         print HFILE $_;
      }
#   } elsif (/^[ \t]*typedef[ \t]*union[ \t]*YYSTYPE[ \t]*{[ \t]*$/) {
   } elsif (/^[ \t]*typedef[ \t]*union[ \t]*YYSTYPE[ \t]*$/) {
     while (<YTABC>) {
       last if (/^[ \t]*{[ \t]*$/);
     }
     print "  Found typedef union..\n";
      if (! $printedclass) {
         print HFILE "class $class {\n";
         $printedclass = 1;
      }
      print HFILE "public:\n   union YYSTYPE  {\n";
      last;
   }
   print CFILE $_;

}

# Fill in the definition of the YYSTYPE union in the generated header file.
#
while (<YTABC>) {
  print "HFILE 2 line: $_";
#   last if (/^[ \t]*}[ \t]*YYSTYPE[ \t]*;[ \t]*$/);
   last if (/^[ \t]*}[ \t]*$/);
   print HFILE "   $_";
}

# Fill in the definition of all the token codes in the generated header file
# (as a class local enum type).
#
print HFILE
"   };
   enum YYTOKENUM {
";
while (<YTABC>) {
  print "HFILE line: $_";
   if (/^[ \t]*\#[ \t]*define[ \t]+([a-zA-Z_][a-zA-Z_0-9]*)[ \t]+([0-9]+)[ \t]*$/) {
      $tokname=$1;
      $tokcode=$2;
#      last if ($tokname eq "YYERRCODE");
      last if ($tokname eq "YYMAXUTOK");
      if ($tokname ne "YYMAXDEPTH") {
         print HFILE "      $tokname=$tokcode,\n";
      }
   }
}

print HFILE "      $tokname=$tokcode\n";

print "Filling standard header file trailer..\n";
# Fill in the standard header file trailer.
#
print HFILE
"   };
   static yytabelem yyexca[];
   static yytabelem yyact[];
   static yytabelem yypact[];
   static yytabelem yypgo[];
   static yytabelem yyr1[];
   static yytabelem yyr2[];
   static yytabelem yychk[];
   static yytabelem yydef[];
#if YYDEBUG
   static yytoktype yytoks[];
   static char *    yyreds[];
#endif

   YYSTYPE          yylval, yyval;
   int              yydebug;
   YYSTYPE *        yypv;
   int *            yyps;
   int              yystate;
   int              yytmp;
   int              yynerrs;
   int              yyerrflag;
   int              yychar;
";
if (defined($opt_r)) {
   print HFILE
"   YYSTYPE *        yyv;
   int *            yys;
   int              yymaxdepth;
   int *            maxyyps;

   void
   yyerror(const char *);

   ${class}(int init_debug=YYDEBUG, int init_depth=$opt_r) :
      yydebug(init_debug),
      yymaxdepth(init_depth)
      {
         yys = (int *)malloc(sizeof(int) * yymaxdepth);
         yyv = (union YYSTYPE *)malloc(sizeof(union YYSTYPE) * yymaxdepth);
         if ( (! yys) || (! yyv) ) {
            yyerror(\"${class}::${class} : no memory for stack.\");
         }
         maxyyps = &yys[yymaxdepth];
      };

   ~${class}()
      {
         if (yyv) free((void *)yyv);
         if (yys) free((void *)yys);
      };
";
} else {

   print HFILE
"   YYSTYPE          yyv[ YYMAXDEPTH ];
   int              yys[ YYMAXDEPTH ];

   ${class}(int init_debug=YYDEBUG) : yydebug(init_debug) {};

   void
   yyerror(const char *);
";
}

print HFILE
"
   int
   yyparse();

   int
   yylex();

};

#endif /* ${class}_h */
";

# OK. We are done with the header file.
#
close(HFILE);

# Copy a #include of the new header file into the .c file in place of the
# information just processed out of y.tab.c
#
print CFILE "#include \"${yaccbase}.h\"\n";

# Now copy the remainder of y.tab.c to the .c file, deleteing some lines
# that used to define variables (which are now defined in the header) and
# inserting classname:: in appropriate places for the definitions of the
# static variables (that define the parse tables) and the yyparse member
# function.
#
# Just copy everything until the first yytabelem variable definition (this
# avoids making unintentional matches in the user defined code).
#
while (<YTABC>) {
  print "CFILE 1 line: $_";
#   if (/^[ \t]*yytabelem[ \t]+([a-zA-Z_][a-zA-Z_0-9]*)(.*)$/) {
   if (/^[ \t]*static[ \t]*const[ \t]*yytype_([a-zA-Z_0-9]*)[ \t]+([a-zA-Z_][a-zA-Z_0-9]*)(.*)$/) {
      $type=$1;
      $item=$2;
      $rest=$3;
      print CFILE "static const yytype_$type ${class}::${item}${rest}\n";
      last;
   } else {
      print CFILE $_;
   }
}

# Now match and replace everything until seeing the yyparse function
# definition.
#
my $line_buffer = '';
while (<YTABC>) {
   if (/^[ \t]*static[ \t]*char[ \t]*\*[ \t]*$/ || /^[ \t]*static[ \t]*YYSIZE_T[ \t]*$/ || /^[ \t]*static[ \t]*void*$/)
   {
     chomp();
     $line_buffer .= "$_ ";
     next;
   }
   if ($line_buffer)
   {
     $_ = $line_buffer . $_;
     $line_buffer = '';
   }
  print "CFILE line: $_";
   if (/^[ \t]*yyparse[ \t]*\([ \t]*\)(.*)$/) {
      $rest=$1;
      print CFILE "${class}::yyparse()$rest\n";
      last;
#   } elsif (/^[ \t]*yytabelem[ \t]+([a-zA-Z_][a-zA-Z_0-9]*)(.*)$/) {
   } elsif (/^[ \t]*static[ \t]*const[ \t]*yytype_([a-zA-Z_0-9]*)[ \t]+([a-zA-Z_][a-zA-Z_0-9]*)(.*)$/) {
      $type=$1;
      $item=$2;
      $rest=$3;
      print CFILE "yytype_$type ${class}::${item}${rest}\n";
   } elsif (/^[ \t]*yytoktype[ \t]+([a-zA-Z_][a-zA-Z_0-9]*)(.*)$/) {
      $item=$1;
      $rest=$2;
      print CFILE "yytoktype ${class}::${item}${rest}\n";
   } elsif (/^char[ \t]*\*[ \t]*([a-zA-Z_][a-zA-Z_0-9]*)(.*)$/) {
      $item=$1;
      $rest=$2;
      print CFILE "char * ${class}::${item}${rest}\n";
   } elsif (/^int[ \t]*([a-zA-Z_][a-zA-Z_0-9]*)(.*)$/) {
      $item=$1;
      $rest=$2;
      print CFILE "int ${class}::${item}${rest}\n";
   } elsif (/^[ \t]*static[ \t]*YYSIZE_T[ \t]*([a-zA-Z_][a-zA-Z_0-9]*)(.*)$/) {
      $item=$1;
      $rest=$2;
      print CFILE "static YYSIZE_T ${class}::${item}${rest}\n";
   } elsif (/^[ \t]*static[ \t]*void[ \t]*([a-zA-Z_][a-zA-Z_0-9]*)(.*)$/) {
      $item=$1;
      $rest=$2;
      print CFILE "static void ${class}::${item}${rest}\n";
   } elsif (/^const[ \t]*char[ \t]*\*[ \t]*([a-zA-Z_][a-zA-Z_0-9]*)(.*)$/) {
      $item=$1;
      $rest=$2;
      print CFILE "const char * ${class}::${item}${rest}\n";
   } elsif (/^[ \t]*static[ \t]*char[ \t]*\*[ \t]*([a-zA-Z_][a-zA-Z_0-9]*)(.*)$/) {
      $item=$1;
      $rest=$2;
      print CFILE "static char * ${class}::${item}${rest}\n";
   } elsif
        (/^[ \t]*typedef[ \t]+struct[ \t]*{.*}[ \t]*yytoktype[ \t]*;[ \t]*$/) {
      print CFILE "\n";
   } elsif (/^[ \t]*int[ \t]+yydebug[ \t]*;/) {
      print CFILE "\n";
   } elsif (/^YYSTYPE[ \t]+yyv[ \t]*\[[ \t]*YYMAXDEPTH[ \t]*\][ \t]*;/) {
      print CFILE "\n";
   } elsif (/^int[ \t]+yys[ \t]*\[[ \t]*YYMAXDEPTH[ \t]*\][ \t]*;/) {
      print CFILE "\n";
   } elsif (/^YYSTYPE[ \t]*\*[ \t]*yypv[ \t]*;/) {
      print CFILE "\n";
   } elsif (/^int[ \t]*\*[ \t]*yyps[ \t]*;/) {
      print CFILE "\n";
   } elsif (/^int[ \t]+yystate[ \t]*;/) {
      print CFILE "\n";
   } elsif (/^int[ \t]+yytmp[ \t]*;/) {
      print CFILE "\n";
   } elsif (/^int[ \t]+yynerrs[ \t]*;/) {
      print CFILE "\n";
   } elsif (/^int[ \t]+yyerrflag[ \t]*;/) {
      print CFILE "\n";
   } elsif (/^int[ \t]+yychar[ \t]*;/) {
      print CFILE "\n";
   } else {
      print CFILE $_;
   }
}

# After yyparse, just copy rest of file (unless we want to create a dynamic
# parse stack, in which case search for stack overflow code).
#
if (defined($opt_r)) {
   while(<YTABC>) {
      if (/^([ \t]*)if[ \t]*\([ \t]*\+\+yy_ps[ \t]*>=[ \t]*&[ \t]*yys[ \t]*\[[ \t]*YYMAXDEPTH[ \t]*\][ \t]*\)/) {
         $leading=$1;
         if ((($_=<YTABC>) && (/^[ \t]*\{[ \t]*$/)) &&
             (($_=<YTABC>) && (/^[ \t]*yyerror[ \t]*\(/)) &&
             (($_=<YTABC>) && (/^[ \t]*YYABORT[ \t]*;/)) &&
             (($_=<YTABC>) && (/^[ \t]*\}[ \t]*$/))) {
            $fixedoverflow=1;
            print CFILE
"${leading}if( ++yyps >= maxyyps ) {
${leading}      int tv = yypv - yyv;
${leading}      int ts = yyps - yys;
${leading}      int t_v = yy_pv - yyv;
${leading}      int t_s = yy_ps - yys;
${leading}      yymaxdepth *= 2;
${leading}      yyv = (YYSTYPE*)realloc((void*)yyv, yymaxdepth*sizeof(YYSTYPE));
${leading}      yys = (int*)realloc((void*)yys, yymaxdepth*sizeof(int));
${leading}      if ( (! yyv) || (! yys) ) {
${leading}              yyerror( \"${class}::yyparse stack overflow\" );
${leading}              YYABORT;
${leading}      }
${leading}      yyps = yys + ts;
${leading}      yypv = yyv + tv;
${leading}      yy_ps = yys + t_s;
${leading}      yy_pv = yyv + t_v;
${leading}      maxyyps = &yys[yymaxdepth];
${leading}}
";
         } else {
            die "Cannot recognize stack overflow code in y.tab.c.\n";
         }
         last;
      } else {
         print CFILE $_;
      }
   }
   if (! defined($fixedoverflow)) {
      die "Never saw the stack overflow code in y.tab.c.\n";
   }
}

while (<YTABC>) {
   print CFILE $_;
}

#unlink("y.tab.c");